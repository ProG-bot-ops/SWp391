// AI Chatbot for Hospital Appointment System
class AIChatbot {
    constructor() {
        this.conversationHistory = [];
        this.currentContext = null;
        this.userInfo = {};
        this.appointmentData = {};
        this.isProcessing = false;
        
        // Initialize chatbot
        this.init();
    }

    init() {
        this.displayWelcomeMessage();
        this.setupEventListeners();
        this.loadConversationHistory();
    }

    displayWelcomeMessage() {
        const welcomeMessage = {
            type: 'bot',
            content: `Xin ch√†o! T√¥i l√† AI Assistant c·ªßa b·ªánh vi·ªán. T√¥i c√≥ th·ªÉ gi√∫p b·∫°n:

üîπ ƒê·∫∑t l·ªãch kh√°m b·ªánh
üîπ Ki·ªÉm tra l·ªãch h·∫πn hi·ªán t·∫°i
üîπ H·ªßy ho·∫∑c thay ƒë·ªïi l·ªãch h·∫πn
üîπ Cung c·∫•p th√¥ng tin b·ªánh vi·ªán
üîπ H∆∞·ªõng d·∫´n quy tr√¨nh kh√°m b·ªánh

B·∫°n c√≥ th·ªÉ nh·∫≠p tin nh·∫Øn ho·∫∑c ch·ªçn thao t√°c nhanh b√™n tr√°i. T√¥i s·∫Ω h·ªó tr·ª£ b·∫°n 24/7! üòä`,
            quickReplies: [
                'ƒê·∫∑t l·ªãch kh√°m',
                'Ki·ªÉm tra l·ªãch h·∫πn',
                'Th√¥ng tin b·ªánh vi·ªán',
                'H∆∞·ªõng d·∫´n quy tr√¨nh'
            ],
            timestamp: new Date()
        };
        
        this.addMessage(welcomeMessage);
    }

    setupEventListeners() {
        // Handle Enter key in input
        document.getElementById('messageInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                this.sendMessage();
            }
        });

        // Auto-scroll to bottom when new messages are added
        const chatMessages = document.getElementById('chatMessages');
        const observer = new MutationObserver(() => {
            chatMessages.scrollTop = chatMessages.scrollHeight;
        });
        observer.observe(chatMessages, { childList: true });
    }

    async sendMessage() {
        const input = document.getElementById('messageInput');
        const message = input.value.trim();
        
        if (!message || this.isProcessing) return;
        
        // Add user message
        this.addMessage({
            type: 'user',
            content: message,
            timestamp: new Date()
        });
        
        input.value = '';
        this.isProcessing = true;
        
        // Show typing indicator
        this.showTypingIndicator();
        
        try {
            // Process message with AI
            const response = await this.processMessage(message);
            
            // Hide typing indicator
            this.hideTypingIndicator();
            
            // Add bot response
            this.addMessage(response);
            
        } catch (error) {
            console.error('Error processing message:', error);
            this.hideTypingIndicator();
            
            this.addMessage({
                type: 'bot',
                content: 'Xin l·ªói, c√≥ l·ªói x·∫£y ra. Vui l√≤ng th·ª≠ l·∫°i sau.',
                timestamp: new Date()
            });
        }
        
        this.isProcessing = false;
    }

    async processMessage(message) {
        const lowerMessage = message.toLowerCase();
        
        // Intent recognition
        const intent = this.recognizeIntent(lowerMessage);
        
        // Process based on intent
        switch (intent) {
            case 'book_appointment':
                return await this.handleBookAppointment(message);
            case 'check_appointment':
                return await this.handleCheckAppointment(message);
            case 'cancel_appointment':
                return await this.handleCancelAppointment(message);
            case 'hospital_info':
                return this.handleHospitalInfo();
            case 'process_guide':
                return this.handleProcessGuide();
            case 'greeting':
                return this.handleGreeting();
            case 'help':
                return this.handleHelp();
            default:
                return this.handleUnknownIntent(message);
        }
    }

    recognizeIntent(message) {
        const intents = {
            book_appointment: [
                'ƒë·∫∑t l·ªãch', 'ƒë·∫∑t h·∫πn', 'kh√°m b·ªánh', 'l·ªãch kh√°m', 'ƒë·∫∑t l·ªãch kh√°m',
                'book appointment', 'schedule', 'appointment'
            ],
            check_appointment: [
                'ki·ªÉm tra', 'xem l·ªãch', 'l·ªãch h·∫πn', 'appointment status',
                'check appointment', 'my appointment'
            ],
            cancel_appointment: [
                'h·ªßy l·ªãch', 'h·ªßy h·∫πn', 'cancel appointment', 'cancel booking'
            ],
            hospital_info: [
                'th√¥ng tin', 'b·ªánh vi·ªán', 'ƒë·ªãa ch·ªâ', 's·ªë ƒëi·ªán tho·∫°i',
                'hospital info', 'contact', 'address'
            ],
            process_guide: [
                'quy tr√¨nh', 'h∆∞·ªõng d·∫´n', 'c√°ch kh√°m', 'process', 'guide'
            ],
            greeting: [
                'xin ch√†o', 'hello', 'hi', 'ch√†o', 'good morning', 'good afternoon'
            ],
            help: [
                'gi√∫p ƒë·ª°', 'help', 'h·ªó tr·ª£', 'support'
            ]
        };

        for (const [intent, keywords] of Object.entries(intents)) {
            if (keywords.some(keyword => message.includes(keyword))) {
                return intent;
            }
        }
        
        return 'unknown';
    }

    async handleBookAppointment(message) {
        if (!this.appointmentData.step) {
            this.appointmentData = { step: 'name' };
            return {
                type: 'bot',
                content: 'T√¥i s·∫Ω gi√∫p b·∫°n ƒë·∫∑t l·ªãch kh√°m. ƒê·ªÉ b·∫Øt ƒë·∫ßu, vui l√≤ng cho t√¥i bi·∫øt h·ªç t√™n c·ªßa b·∫°n:',
                timestamp: new Date()
            };
        }

        // Extract information from message
        const extractedInfo = this.extractAppointmentInfo(message);
        
        if (this.appointmentData.step === 'name') {
            this.appointmentData.name = extractedInfo.name || message;
            this.appointmentData.step = 'phone';
            return {
                type: 'bot',
                content: `C·∫£m ∆°n ${this.appointmentData.name}! Vui l√≤ng cung c·∫•p s·ªë ƒëi·ªán tho·∫°i c·ªßa b·∫°n:`,
                timestamp: new Date()
            };
        }
        
        if (this.appointmentData.step === 'phone') {
            this.appointmentData.phone = extractedInfo.phone || message;
            this.appointmentData.step = 'department';
            return {
                type: 'bot',
                content: 'B·∫°n mu·ªën kh√°m khoa n√†o? D∆∞·ªõi ƒë√¢y l√† c√°c khoa hi·ªán c√≥:',
                quickReplies: [
                    'Khoa Tim m·∫°ch',
                    'Khoa Nhi',
                    'Khoa Da li·ªÖu',
                    'Khoa M·∫Øt',
                    'Khoa Tai m≈©i h·ªçng',
                    'Khoa N·ªôi t·ªïng qu√°t'
                ],
                timestamp: new Date()
            };
        }
        
        if (this.appointmentData.step === 'department') {
            this.appointmentData.department = message;
            this.appointmentData.step = 'date';
            return {
                type: 'bot',
                content: 'B·∫°n mu·ªën ƒë·∫∑t l·ªãch v√†o ng√†y n√†o? (Vui l√≤ng nh·∫≠p theo ƒë·ªãnh d·∫°ng DD/MM/YYYY):',
                timestamp: new Date()
            };
        }
        
        if (this.appointmentData.step === 'date') {
            const date = this.parseDate(message);
            if (!date) {
                return {
                    type: 'bot',
                    content: 'Vui l√≤ng nh·∫≠p ng√†y theo ƒë·ªãnh d·∫°ng DD/MM/YYYY (v√≠ d·ª•: 25/12/2024):',
                    timestamp: new Date()
                };
            }
            this.appointmentData.date = date;
            this.appointmentData.step = 'time';
            return {
                type: 'bot',
                content: 'B·∫°n mu·ªën kh√°m v√†o gi·ªù n√†o?',
                quickReplies: [
                    '8:00 - 9:00',
                    '9:00 - 10:00',
                    '10:00 - 11:00',
                    '14:00 - 15:00',
                    '15:00 - 16:00',
                    '16:00 - 17:00'
                ],
                timestamp: new Date()
            };
        }
        
        if (this.appointmentData.step === 'time') {
            this.appointmentData.time = message;
            this.appointmentData.step = 'confirm';
            
            return {
                type: 'bot',
                content: `Vui l√≤ng x√°c nh·∫≠n th√¥ng tin ƒë·∫∑t l·ªãch:

üë§ **H·ªç t√™n:** ${this.appointmentData.name}
üìû **S·ªë ƒëi·ªán tho·∫°i:** ${this.appointmentData.phone}
üè• **Khoa:** ${this.appointmentData.department}
üìÖ **Ng√†y:** ${this.appointmentData.date}
‚è∞ **Gi·ªù:** ${this.appointmentData.time}

Th√¥ng tin tr√™n c√≥ ch√≠nh x√°c kh√¥ng?`,
                quickReplies: ['X√°c nh·∫≠n', 'S·ª≠a l·∫°i'],
                timestamp: new Date()
            };
        }
        
        if (this.appointmentData.step === 'confirm') {
            if (message.toLowerCase().includes('x√°c nh·∫≠n') || message.toLowerCase().includes('ƒë√∫ng')) {
                return await this.submitAppointment();
            } else {
                this.appointmentData = { step: 'name' };
                return {
                    type: 'bot',
                    content: 'Vui l√≤ng b·∫Øt ƒë·∫ßu l·∫°i. Cho t√¥i bi·∫øt h·ªç t√™n c·ªßa b·∫°n:',
                    timestamp: new Date()
                };
            }
        }
    }

    async submitAppointment() {
        try {
            // Show loading
            this.showLoading();
            
            // Prepare appointment data
            const appointmentData = {
                patientName: this.appointmentData.name,
                phoneNumber: this.appointmentData.phone,
                department: this.appointmentData.department,
                appointmentDate: this.appointmentData.date,
                appointmentTime: this.appointmentData.time,
                status: 'Pending'
            };
            
            // Call API to create appointment
            const response = await this.createAppointmentAPI(appointmentData);
            
            this.hideLoading();
            
            if (response.success) {
                this.appointmentData = {};
                return {
                    type: 'bot',
                    content: `‚úÖ **ƒê·∫∑t l·ªãch th√†nh c√¥ng!**

M√£ l·ªãch h·∫πn: **${response.appointmentCode}**
Ng√†y kh√°m: ${appointmentData.appointmentDate}
Gi·ªù kh√°m: ${appointmentData.appointmentTime}

Vui l√≤ng ƒë·∫øn b·ªánh vi·ªán tr∆∞·ªõc 15 ph√∫t so v·ªõi gi·ªù h·∫πn. Mang theo CMND/CCCD v√† b·∫£o hi·ªÉm y t·∫ø (n·∫øu c√≥).

C·∫£m ∆°n b·∫°n ƒë√£ s·ª≠ d·ª•ng d·ªãch v·ª• c·ªßa ch√∫ng t√¥i! üè•`,
                    timestamp: new Date()
                };
            } else {
                throw new Error(response.message);
            }
            
        } catch (error) {
            this.hideLoading();
            return {
                type: 'bot',
                content: `‚ùå **ƒê·∫∑t l·ªãch th·∫•t b·∫°i!**

L·ªói: ${error.message}

Vui l√≤ng th·ª≠ l·∫°i ho·∫∑c li√™n h·ªá hotline 1900-xxxx ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£.`,
                timestamp: new Date()
            };
        }
    }

    async handleCheckAppointment(message) {
        // Extract phone number or appointment code
        const phoneOrCode = this.extractPhoneOrCode(message);
        
        if (!phoneOrCode) {
            return {
                type: 'bot',
                content: 'Vui l√≤ng cung c·∫•p s·ªë ƒëi·ªán tho·∫°i ho·∫∑c m√£ l·ªãch h·∫πn ƒë·ªÉ ki·ªÉm tra:',
                timestamp: new Date()
            };
        }
        
        try {
            this.showLoading();
            const appointments = await this.getAppointmentsAPI(phoneOrCode);
            this.hideLoading();
            
            if (appointments.length === 0) {
                return {
                    type: 'bot',
                    content: 'Kh√¥ng t√¨m th·∫•y l·ªãch h·∫πn n√†o v·ªõi th√¥ng tin b·∫°n cung c·∫•p. Vui l√≤ng ki·ªÉm tra l·∫°i.',
                    timestamp: new Date()
                };
            }
            
            let response = 'üìã **L·ªãch h·∫πn c·ªßa b·∫°n:**\n\n';
            appointments.forEach((apt, index) => {
                response += `${index + 1}. **M√£:** ${apt.appointmentCode}\n`;
                response += `   **Ng√†y:** ${apt.appointmentDate}\n`;
                response += `   **Gi·ªù:** ${apt.appointmentTime}\n`;
                response += `   **Khoa:** ${apt.department}\n`;
                response += `   **Tr·∫°ng th√°i:** ${this.getStatusText(apt.status)}\n\n`;
            });
            
            return {
                type: 'bot',
                content: response,
                quickReplies: ['H·ªßy l·ªãch h·∫πn', 'ƒê·∫∑t l·ªãch m·ªõi'],
                timestamp: new Date()
            };
            
        } catch (error) {
            this.hideLoading();
            return {
                type: 'bot',
                content: 'C√≥ l·ªói x·∫£y ra khi ki·ªÉm tra l·ªãch h·∫πn. Vui l√≤ng th·ª≠ l·∫°i sau.',
                timestamp: new Date()
            };
        }
    }

    async handleCancelAppointment(message) {
        const appointmentCode = this.extractAppointmentCode(message);
        
        if (!appointmentCode) {
            return {
                type: 'bot',
                content: 'Vui l√≤ng cung c·∫•p m√£ l·ªãch h·∫πn ƒë·ªÉ h·ªßy:',
                timestamp: new Date()
            };
        }
        
        try {
            this.showLoading();
            const result = await this.cancelAppointmentAPI(appointmentCode);
            this.hideLoading();
            
            if (result.success) {
                return {
                    type: 'bot',
                    content: `‚úÖ **H·ªßy l·ªãch h·∫πn th√†nh c√¥ng!**

M√£ l·ªãch h·∫πn: ${appointmentCode}
ƒê√£ ƒë∆∞·ª£c h·ªßy th√†nh c√¥ng.

B·∫°n c√≥ th·ªÉ ƒë·∫∑t l·ªãch m·ªõi b·∫•t c·ª© l√∫c n√†o.`,
                    timestamp: new Date()
                };
            } else {
                throw new Error(result.message);
            }
            
        } catch (error) {
            this.hideLoading();
            return {
                type: 'bot',
                content: `‚ùå **H·ªßy l·ªãch h·∫πn th·∫•t b·∫°i!**

L·ªói: ${error.message}

Vui l√≤ng ki·ªÉm tra l·∫°i m√£ l·ªãch h·∫πn ho·∫∑c li√™n h·ªá hotline ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£.`,
                timestamp: new Date()
            };
        }
    }

    handleHospitalInfo() {
        return {
            type: 'bot',
            content: `üè• **Th√¥ng tin B·ªánh vi·ªán**

üìç **ƒê·ªãa ch·ªâ:** 123 ƒê∆∞·ªùng ABC, Qu·∫≠n 1, TP.HCM
üìû **Hotline:** 1900-xxxx
üìß **Email:** info@hospital.com
üåê **Website:** www.hospital.com

‚è∞ **Gi·ªù l√†m vi·ªác:**
- Th·ª© 2 - Th·ª© 6: 7:00 - 18:00
- Th·ª© 7: 7:00 - 12:00
- Ch·ªß nh·∫≠t: Ngh·ªâ

üöó **Ph∆∞∆°ng ti·ªán:**
- Xe bu√Ωt: Tuy·∫øn 01, 02, 03
- Taxi: C√≥ b√£i ƒë·ªó xe
- Xe m√°y: C√≥ b√£i gi·ªØ xe

üÖøÔ∏è **B√£i ƒë·ªó xe:** Mi·ªÖn ph√≠ cho b·ªánh nh√¢n`,
            timestamp: new Date()
        };
    }

    handleProcessGuide() {
        return {
            type: 'bot',
            content: `üìã **Quy tr√¨nh kh√°m b·ªánh:**

1Ô∏è‚É£ **ƒê·∫∑t l·ªãch h·∫πn**
   - Qua chatbot n√†y
   - G·ªçi hotline 1900-xxxx
   - ƒê·∫øn tr·ª±c ti·∫øp b·ªánh vi·ªán

2Ô∏è‚É£ **Chu·∫©n b·ªã**
   - Mang CMND/CCCD
   - B·∫£o hi·ªÉm y t·∫ø (n·∫øu c√≥)
   - S·ªï kh√°m b·ªánh c≈© (n·∫øu c√≥)

3Ô∏è‚É£ **ƒê·∫øn b·ªánh vi·ªán**
   - ƒê·∫øn tr∆∞·ªõc 15 ph√∫t
   - L√†m th·ªß t·ª•c ƒëƒÉng k√Ω
   - Thanh to√°n ph√≠ kh√°m

4Ô∏è‚É£ **Kh√°m b·ªánh**
   - ƒê∆∞·ª£c g·ªçi v√†o ph√≤ng kh√°m
   - B√°c sƒ© kh√°m v√† t∆∞ v·∫•n
   - Nh·∫≠n ƒë∆°n thu·ªëc (n·∫øu c·∫ßn)

5Ô∏è‚É£ **K·∫øt th√∫c**
   - Thanh to√°n thu·ªëc (n·∫øu c√≥)
   - Nh·∫≠n h·∫πn t√°i kh√°m (n·∫øu c·∫ßn)

‚ùì **C·∫ßn h·ªó tr·ª£ th√™m?** G·ªçi hotline ho·∫∑c chat v·ªõi t√¥i!`,
            timestamp: new Date()
        };
    }

    handleGreeting() {
        const greetings = [
            'Xin ch√†o! T√¥i c√≥ th·ªÉ gi√∫p g√¨ cho b·∫°n? üòä',
            'Ch√†o b·∫°n! B·∫°n c·∫ßn h·ªó tr·ª£ g√¨ v·ªÅ ƒë·∫∑t l·ªãch kh√°m kh√¥ng?',
            'Xin ch√†o! T√¥i s·∫µn s√†ng h·ªó tr·ª£ b·∫°n ƒë·∫∑t l·ªãch kh√°m b·ªánh!'
        ];
        
        return {
            type: 'bot',
            content: greetings[Math.floor(Math.random() * greetings.length)],
            quickReplies: ['ƒê·∫∑t l·ªãch kh√°m', 'Ki·ªÉm tra l·ªãch h·∫πn', 'Th√¥ng tin b·ªánh vi·ªán'],
            timestamp: new Date()
        };
    }

    handleHelp() {
        return {
            type: 'bot',
            content: `üîß **T√¥i c√≥ th·ªÉ gi√∫p b·∫°n:**

üìÖ **ƒê·∫∑t l·ªãch kh√°m:** T√¥i s·∫Ω h∆∞·ªõng d·∫´n t·ª´ng b∆∞·ªõc
üîç **Ki·ªÉm tra l·ªãch h·∫πn:** Xem l·ªãch h·∫πn hi·ªán t·∫°i
‚ùå **H·ªßy l·ªãch h·∫πn:** H·ªßy l·ªãch h·∫πn kh√¥ng c·∫ßn thi·∫øt
üè• **Th√¥ng tin b·ªánh vi·ªán:** ƒê·ªãa ch·ªâ, gi·ªù l√†m vi·ªác
üìã **Quy tr√¨nh kh√°m:** H∆∞·ªõng d·∫´n chi ti·∫øt

B·∫°n mu·ªën l√†m g√¨? Ch·ªçn t·ª´ menu ho·∫∑c nh·∫≠p tin nh·∫Øn!`,
            quickReplies: ['ƒê·∫∑t l·ªãch kh√°m', 'Ki·ªÉm tra l·ªãch h·∫πn', 'Th√¥ng tin b·ªánh vi·ªán'],
            timestamp: new Date()
        };
    }

    handleUnknownIntent(message) {
        return {
            type: 'bot',
            content: `Xin l·ªói, t√¥i ch∆∞a hi·ªÉu r√µ y√™u c·∫ßu c·ªßa b·∫°n. 

B·∫°n c√≥ th·ªÉ:
- ƒê·∫∑t l·ªãch kh√°m
- Ki·ªÉm tra l·ªãch h·∫πn
- H·ªßy l·ªãch h·∫πn
- Xem th√¥ng tin b·ªánh vi·ªán
- T√¨m hi·ªÉu quy tr√¨nh kh√°m

Ho·∫∑c g√µ "gi√∫p ƒë·ª°" ƒë·ªÉ xem t·∫•t c·∫£ t√≠nh nƒÉng!`,
            quickReplies: ['ƒê·∫∑t l·ªãch kh√°m', 'Ki·ªÉm tra l·ªãch h·∫πn', 'Gi√∫p ƒë·ª°'],
            timestamp: new Date()
        };
    }

    // Utility functions
    extractAppointmentInfo(message) {
        const info = {};
        
        // Extract name (simple heuristic)
        if (message.length > 2 && message.length < 50) {
            info.name = message.trim();
        }
        
        // Extract phone number
        const phoneRegex = /(\d{10,11})/;
        const phoneMatch = message.match(phoneRegex);
        if (phoneMatch) {
            info.phone = phoneMatch[1];
        }
        
        return info;
    }

    extractPhoneOrCode(message) {
        // Extract phone number
        const phoneRegex = /(\d{10,11})/;
        const phoneMatch = message.match(phoneRegex);
        if (phoneMatch) {
            return phoneMatch[1];
        }
        
        // Extract appointment code (assuming format like APT-XXXX)
        const codeRegex = /(APT-\d{4})/i;
        const codeMatch = message.match(codeRegex);
        if (codeMatch) {
            return codeMatch[1];
        }
        
        return null;
    }

    extractAppointmentCode(message) {
        const codeRegex = /(APT-\d{4})/i;
        const codeMatch = message.match(codeRegex);
        return codeMatch ? codeMatch[1] : null;
    }

    parseDate(dateString) {
        const dateRegex = /(\d{1,2})\/(\d{1,2})\/(\d{4})/;
        const match = dateString.match(dateRegex);
        
        if (match) {
            const day = parseInt(match[1]);
            const month = parseInt(match[2]) - 1;
            const year = parseInt(match[3]);
            
            const date = new Date(year, month, day);
            const today = new Date();
            
            // Check if date is valid and in the future
            if (date > today && date.getDate() === day && date.getMonth() === month && date.getFullYear() === year) {
                return `${day.toString().padStart(2, '0')}/${(month + 1).toString().padStart(2, '0')}/${year}`;
            }
        }
        
        return null;
    }

    getStatusText(status) {
        const statusMap = {
            'Pending': 'Ch·ªù x√°c nh·∫≠n',
            'Confirmed': 'ƒê√£ x√°c nh·∫≠n',
            'Completed': 'ƒê√£ ho√†n th√†nh',
            'Cancelled': 'ƒê√£ h·ªßy'
        };
        return statusMap[status] || status;
    }

    // API functions (mock for now, can be replaced with real API calls)
    async createAppointmentAPI(data) {
        // Simulate API call
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        // Mock response
        return {
            success: true,
            appointmentCode: 'APT-' + Math.random().toString(36).substr(2, 4).toUpperCase(),
            message: 'Appointment created successfully'
        };
    }

    async getAppointmentsAPI(phoneOrCode) {
        // Simulate API call
        await new Promise(resolve => setTimeout(resolve, 1500));
        
        // Mock response
        return [
            {
                appointmentCode: 'APT-1234',
                appointmentDate: '25/12/2024',
                appointmentTime: '9:00 - 10:00',
                department: 'Khoa Tim m·∫°ch',
                status: 'Confirmed'
            }
        ];
    }

    async cancelAppointmentAPI(appointmentCode) {
        // Simulate API call
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // Mock response
        return {
            success: true,
            message: 'Appointment cancelled successfully'
        };
    }

    // UI functions
    addMessage(message) {
        const chatMessages = document.getElementById('chatMessages');
        const messageElement = this.createMessageElement(message);
        chatMessages.appendChild(messageElement);
        
        // Save to conversation history
        this.conversationHistory.push(message);
        this.saveConversationHistory();
    }

    createMessageElement(message) {
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${message.type}`;
        
        const avatar = document.createElement('div');
        avatar.className = 'message-avatar';
        avatar.innerHTML = message.type === 'user' ? '<i class="fas fa-user"></i>' : '<i class="fas fa-robot"></i>';
        
        const content = document.createElement('div');
        content.className = 'message-content';
        content.innerHTML = message.content;
        
        const time = document.createElement('div');
        time.className = 'message-time';
        time.textContent = this.formatTime(message.timestamp);
        
        messageDiv.appendChild(avatar);
        messageDiv.appendChild(content);
        messageDiv.appendChild(time);
        
        // Add quick replies if available
        if (message.quickReplies && message.quickReplies.length > 0) {
            const quickReplies = document.createElement('div');
            quickReplies.className = 'quick-replies';
            
            message.quickReplies.forEach(reply => {
                const button = document.createElement('button');
                button.className = 'quick-reply-btn';
                button.textContent = reply;
                button.onclick = () => this.handleQuickReply(reply);
                quickReplies.appendChild(button);
            });
            
            content.appendChild(quickReplies);
        }
        
        return messageDiv;
    }

    handleQuickReply(reply) {
        document.getElementById('messageInput').value = reply;
        this.sendMessage();
    }

    formatTime(timestamp) {
        return timestamp.toLocaleTimeString('vi-VN', { 
            hour: '2-digit', 
            minute: '2-digit' 
        });
    }

    showTypingIndicator() {
        document.getElementById('typingIndicator').style.display = 'flex';
    }

    hideTypingIndicator() {
        document.getElementById('typingIndicator').style.display = 'none';
    }

    showLoading() {
        const modal = new bootstrap.Modal(document.getElementById('loadingModal'));
        modal.show();
    }

    hideLoading() {
        const modal = bootstrap.Modal.getInstance(document.getElementById('loadingModal'));
        if (modal) {
            modal.hide();
        }
    }

    saveConversationHistory() {
        localStorage.setItem('chatHistory', JSON.stringify(this.conversationHistory));
    }

    loadConversationHistory() {
        const saved = localStorage.getItem('chatHistory');
        if (saved) {
            this.conversationHistory = JSON.parse(saved);
        }
    }

    clearChat() {
        document.getElementById('chatMessages').innerHTML = '';
        this.conversationHistory = [];
        localStorage.removeItem('chatHistory');
        this.displayWelcomeMessage();
    }

    exportChat() {
        const chatText = this.conversationHistory.map(msg => 
            `${msg.type === 'user' ? 'B·∫°n' : 'AI'}: ${msg.content}`
        ).join('\n\n');
        
        const blob = new Blob([chatText], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `chat-export-${new Date().toISOString().split('T')[0]}.txt`;
        a.click();
        URL.revokeObjectURL(url);
    }
}

// Global functions for HTML onclick events
let chatbot;

function quickAction(action) {
    if (!chatbot) return;
    
    const actions = {
        'book': 'T√¥i mu·ªën ƒë·∫∑t l·ªãch kh√°m',
        'check': 'T√¥i mu·ªën ki·ªÉm tra l·ªãch h·∫πn',
        'cancel': 'T√¥i mu·ªën h·ªßy l·ªãch h·∫πn',
        'info': 'Th√¥ng tin b·ªánh vi·ªán'
    };
    
    if (actions[action]) {
        document.getElementById('messageInput').value = actions[action];
        chatbot.sendMessage();
    }
}

function sendMessage() {
    if (chatbot) {
        chatbot.sendMessage();
    }
}

function handleKeyPress(event) {
    if (event.key === 'Enter' && !event.shiftKey) {
        event.preventDefault();
        sendMessage();
    }
}

function clearChat() {
    if (chatbot) {
        chatbot.clearChat();
    }
}

function exportChat() {
    if (chatbot) {
        chatbot.exportChat();
    }
}

// Initialize chatbot when page loads
document.addEventListener('DOMContentLoaded', () => {
    chatbot = new AIChatbot();
}); 